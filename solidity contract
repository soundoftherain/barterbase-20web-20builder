// SPDX-License-Identifier: MIT
pragma solidity 0.8.24;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract DecentralizedMarketplace is Ownable, ReentrancyGuard {
    using SafeERC20 for IERC20;

    struct Product {
        string name;
        uint256 price;      // in wei or token units
        uint256 quantity;
        address seller;
        bool active;
    }

    uint256 public productCount;
    uint256 public marketplaceFee = 200; // 2% in basis points
    uint256 public constant MAX_FEE = 500; // 5% cap
    uint256 public constant MAX_PRODUCTS_PER_BATCH = 50;

    mapping(uint256 => Product) public products;
    mapping(address => mapping(address => uint256)) public sellerBalances;
    mapping(address => uint256) public ownerBalances;
    mapping(address => bool) public allowedTokens;

    // -------------------------------
    // Events
    // -------------------------------
    event ProductAdded(uint256 indexed productId, string name, uint256 price, uint256 quantity, address indexed seller);
    event ProductUpdated(uint256 indexed productId, string name, uint256 price, uint256 quantity, bool active);
    event ProductRemoved(uint256 indexed productId, address indexed seller);
    event ProductPurchased(uint256 indexed productId, address indexed buyer, uint256 quantity, uint256 totalAmount, uint256 feeTaken, address token);
    event Withdrawn(address indexed seller, uint256 amount, address token);
    event FeeWithdrawn(address indexed owner, uint256 amount, address token);
    event FeeUpdated(uint256 newFee);
    event TokenAllowed(address indexed token, bool allowed);

    // -------------------------------
    // Constructor
    // -------------------------------
    constructor(address initialOwner) {
        if (initialOwner != address(0) && initialOwner != _msgSender()) {
            transferOwnership(initialOwner);
        }
    }

    // -------------------------------
    // Owner functions
    // -------------------------------
    function setMarketplaceFee(uint256 newFee) external onlyOwner {
        require(newFee <= MAX_FEE, "Fee too high");
        marketplaceFee = newFee;
        emit FeeUpdated(newFee);
    }

    function setTokenAllowed(address token, bool allowed) external onlyOwner {
        require(token != address(0), "ETH is implicit");
        allowedTokens[token] = allowed;
        emit TokenAllowed(token, allowed);
    }

    function withdrawFees(address token) external onlyOwner nonReentrant {
        uint256 amount = ownerBalances[token];
        require(amount > 0, "No fees to withdraw");
        ownerBalances[token] = 0;

        if (token == address(0)) {
            (bool success, ) = owner().call{value: amount}("");
            require(success, "ETH fee withdrawal failed");
        } else {
            IERC20(token).safeTransfer(owner(), amount);
        }

        emit FeeWithdrawn(owner(), amount, token);
    }

    // -------------------------------
    // Seller functions
    // -------------------------------
    function addProduct(string calldata name, uint256 price, uint256 quantity) external {
        require(bytes(name).length > 0 && bytes(name).length <= 100, "Invalid name length");
        require(price > 0 && quantity > 0, "Price and quantity must be >0");

        uint256 productId = ++productCount;

        products[productId] = Product({
            name: name,
            price: price,
            quantity: quantity,
            seller: msg.sender,
            active: true
        });

        emit ProductAdded(productId, name, price, quantity, msg.sender);
    }

    function updateProduct(uint256 productId, string calldata newName, uint256 newPrice, uint256 addQuantity, bool active) external {
        Product storage product = products[productId];
        require(product.seller == msg.sender, "Not your product");
        require(bytes(newName).length > 0 && bytes(newName).length <= 100, "Invalid name length");
        require(newPrice > 0, "Price must be >0");

        product.name = newName;
        product.price = newPrice;
        product.quantity += addQuantity;
        product.active = active;

        emit ProductUpdated(productId, newName, newPrice, product.quantity, active);
    }

    function removeProduct(uint256 productId) external {
        Product storage product = products[productId];
        require(product.seller == msg.sender, "Not your product");
        require(product.active, "Already inactive");

        product.active = false;
        product.quantity = 0;

        emit ProductRemoved(productId, msg.sender);
    }

    // -------------------------------
    // Buyer functions
    // -------------------------------
    function purchaseProduct(uint256 productId, uint256 quantity, uint256 expectedPrice, uint256 deadline, address token) external payable nonReentrant {
        require(block.timestamp <= deadline, "Transaction expired");
        Product storage product = products[productId];
        require(product.active, "Inactive product");
        require(quantity > 0 && quantity <= product.quantity, "Invalid quantity");
        require(product.price == expectedPrice, "Price mismatch");

        uint256 totalPrice = product.price * quantity;
        uint256 fee = (totalPrice * marketplaceFee) / 10000;
        uint256 sellerProceeds = totalPrice - fee;

        // -----------------
        // CEI pattern
        // -----------------
        unchecked { product.quantity -= quantity; }
        sellerBalances[product.seller][token] += sellerProceeds;
        ownerBalances[token] += fee;

        // Interactions
        if (token == address(0)) {
            require(msg.value >= totalPrice, "Insufficient ETH");
            if (msg.value > totalPrice) {
                uint256 refundAmount = msg.value - totalPrice;
                (bool success, ) = msg.sender.call{value: refundAmount}("");
                require(success, "Refund failed");
            }
        } else {
            require(allowedTokens[token], "Token not allowed");
            require(msg.value == 0, "Do not send ETH");
            IERC20(token).safeTransferFrom(msg.sender, address(this), totalPrice);
        }

        emit ProductPurchased(productId, msg.sender, quantity, totalPrice, fee, token);
    }

    function purchaseMultiple(uint256[] calldata productIds, uint256[] calldata quantities, uint256[] calldata expectedPrices, uint256 deadline, address token) external payable nonReentrant {
        uint256 len = productIds.length;
        require(len <= MAX_PRODUCTS_PER_BATCH, "Too many products");
        require(quantities.length == len && expectedPrices.length == len, "Array mismatch");
        require(block.timestamp <= deadline, "Transaction expired");

        uint256 totalCost = 0;
        address[] memory sellers = new address[](len);
        uint256[] memory costs = new uint256[](len);

        // -----------------
        // CEI pattern: checks + effects first
        // -----------------
        for (uint256 i = 0; i < len; i++) {
            Product storage product = products[productIds[i]];
            require(product.active, "Inactive product");
            require(quantities[i] > 0 && quantities[i] <= product.quantity, "Invalid qty");
            require(product.price == expectedPrices[i], "Price mismatch");

            uint256 cost = product.price * quantities[i];
            totalCost += cost;

            unchecked { product.quantity -= quantities[i]; }

            sellers[i] = product.seller;
            costs[i] = cost;
        }

        // -----------------
        // Interactions
        // -----------------
        if (token == address(0)) {
            require(msg.value >= totalCost, "Insufficient ETH");
            if (msg.value > totalCost) {
                uint256 refundAmount = msg.value - totalCost;
                (bool success, ) = msg.sender.call{value: refundAmount}("");
                require(success, "Refund failed");
            }
        } else {
            require(allowedTokens[token], "Token not allowed");
            require(msg.value == 0, "Do not send ETH");
            IERC20(token).safeTransferFrom(msg.sender, address(this), totalCost);
        }

        // Update balances and emit events
        for (uint256 i = 0; i < len; i++) {
            uint256 fee = (costs[i] * marketplaceFee) / 10000;
            uint256 sellerProceeds = costs[i] - fee;
            sellerBalances[sellers[i]][token] += sellerProceeds;
            ownerBalances[token] += fee;

            emit ProductPurchased(productIds[i], msg.sender, quantities[i], costs[i], fee, token);
        }
    }

    // -------------------------------
    // Withdrawals
    // -------------------------------
    function withdraw(uint256 amount, address token) external nonReentrant {
        uint256 balance = sellerBalances[msg.sender][token];
        require(balance >= amount, "Insufficient balance");
        sellerBalances[msg.sender][token] = balance - amount;

        if (token == address(0)) {
            (bool success, ) = msg.sender.call{value: amount}("");
            require(success, "ETH withdrawal failed");
        } else {
            IERC20(token).safeTransfer(msg.sender, amount);
        }

        emit Withdrawn(msg.sender, amount, token);
    }

    function withdrawAll(address token) external nonReentrant {
        uint256 balance = sellerBalances[msg.sender][token];
        require(balance > 0, "No balance");
        sellerBalances[msg.sender][token] = 0;

        if (token == address(0)) {
            (bool success, ) = msg.sender.call{value: balance}("");
            require(success, "ETH withdrawal failed");
        } else {
            IERC20(token).safeTransfer(msg.sender, balance);
        }

        emit Withdrawn(msg.sender, balance, token);
    }

    // -------------------------------
    // Prevent accidental ETH deposits
    // -------------------------------
    receive() external payable {
        revert("Direct deposits not allowed");
    }

    fallback() external payable {
        revert("Direct deposits not allowed");
    }
}
